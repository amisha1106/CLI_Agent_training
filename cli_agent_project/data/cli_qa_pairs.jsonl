{"question": "Find all files containing a specific text (string) on Linux?", "answer": "Do the following: grep -rnw '/path/to/somewhere/' -e 'pattern' -r or -R is recursive,"}
{"question": "grep: show lines surrounding each match", "answer": "For BSD or GNU grep you can use -B num to set how many lines before the match and -A num for the number of lines after the match. grep -B 3 -A 2 foo README.txt"}
{"question": "How do I recursively grep all directories and subdirectories?", "answer": "grep -r \"texthere\" . The first parameter represents the regular expression to search for, while the second one represents the directory that should be searched. In this case, . means the current directory."}
{"question": "How to grep (search through) committed code in the Git history", "answer": "You should use the pickaxe ( -S ) option of git log . To search for Foo : git log -SFoo -- path_containing_change git log -SFoo --since=2009.1.1 --until=2010.1.1 -- path_containing_change"}
{"question": "How can I use grep to show just filenames on Linux?", "answer": "The standard option grep -l (that is a lowercase L) could do this. From the Unix standard : -l"}
{"question": "How can I grep recursively, but only in files with certain extensions?", "answer": "Just use the --include parameter, like this: grep -inr --include \\*.h --include \\*.cpp CP_Image ~/path[12345] | mailx -s GREP email@domain.example That should do what you want. To take the explanation from HoldOffHunger's answer below:"}
{"question": "Negative matching using grep (match lines that do not contain foo)", "answer": "grep -v is your friend: grep --help | grep invert -v, --invert-match        select non-matching lines"}
{"question": "How can I pipe stderr, and not stdout?", "answer": "First redirect stderr to stdout — the pipe; then redirect stdout to /dev/null (without changing where stderr is going): command 2>&1 >/dev/null | grep 'something' For the details of I/O redirection in all its variety, see the chapter on Redirections in the Bash reference manual. Note that the sequence of I/O redirections is interpreted left-to-right, but pipes are set up before the I/O redirections are interpreted.  File descriptors such as 1 and 2 are references to open file descriptions.  The operation 2>&1 makes file descriptor 2 aka stderr refer to the same open file description as file descriptor 1 aka stdout is currently referring to (see dup2() and open() ).  The operation >/dev/null then changes file descriptor 1 so that it refers to an open file description for /dev/null , but that doesn't change the fact that file descriptor 2 refers to the open file description which file descriptor 1 was originally pointing to — namely, the pipe."}
{"question": "How can I exclude directories from grep -R?", "answer": "SOLUTION 1 (combine find and grep ) The purpose of this solution is not to deal with grep performance but to show a portable solution : should also work with busybox or GNU version older than 2.5. Use find , for excluding directories foo and bar : find /dir \\( -name foo -prune \\) -o \\( -name bar -prune \\) -o -name \"*.sh\" -print"}
{"question": "Can grep show only words that match search pattern?", "answer": "No accepted answer found."}
{"question": "Use grep --exclude/--include syntax to not grep through certain files", "answer": "Use the shell globbing syntax : grep pattern -r --include=\\*.cpp --include=\\*.h rootdir The syntax for --exclude is identical. Note that the star is escaped with a backslash to prevent it from being expanded by the shell (quoting it, such as --include=\"*.cpp\" , would work just as well).  Otherwise, if you had any files in the current working directory that matched the pattern, the command line would expand to something like grep pattern -r --include=foo.cpp --include=bar.cpp rootdir , which would only search files named foo.cpp and bar.cpp , which is quite likely not what you wanted."}
{"question": "How to &#39;grep&#39; a continuous stream?", "answer": "Turn on grep 's line buffering mode when using BSD grep (FreeBSD, Mac OS X etc.) tail -f file | grep --line-buffered my_pattern It looks like a while ago --line-buffered didn't matter for GNU grep (used on pretty much any Linux) as it flushed by default (YMMV for other Unix-likes such as SmartOS, AIX or QNX). However, as of November 2020, --line-buffered is needed (at least with GNU grep 3.5 in openSUSE, but it seems generally needed based on comments below)."}
{"question": "How can I grep Git commits for a certain word?", "answer": "If you want to find all commits where the commit message contains a given word, use git log --grep=word If you want to find all commits where \"word\" was added or removed in the file contents (to be more exact: where the number of occurrences of \"word\" changed), i.e., search the commit contents , use a so-called 'pickaxe' search with git log -Sword"}
{"question": "How do I find files that do not contain a given string pattern?", "answer": "The following command gives me all the files that do not contain the pattern foo : find .  -not  -ipath '.*svn*' -exec  grep  -H -E -o -c  \"foo\"  {} \\; | grep 0"}
{"question": "Delete all local Git branches", "answer": "The 'git branch -d' subcommand can delete more than one branch.  So, simplifying @sblom's answer but adding a critical xargs: git branch -D `git branch --merged | grep -v \\* | xargs` or, further simplified to: git branch --merged | grep -v \\* | xargs git branch -D"}
{"question": "How can I use grep to find a word inside a folder?", "answer": "grep -nr 'yourString*' . The dot at the end searches the current directory. Meaning for each parameter:"}
{"question": "Colorized grep -- viewing the entire file with highlighted matches", "answer": "Here are some ways to do it: grep --color 'pattern\\|$' file grep --color -E 'pattern|$' file egrep --color 'pattern|$' file"}
{"question": "How can I exclude one word with grep?", "answer": "You can do it using -v (for --invert-match ) option of grep as: grep -v \"unwanted_word\" file | grep XXXXXXXX"}
{"question": "Grep only the first match and stop", "answer": "No accepted answer found."}
{"question": "grep a tab in UNIX", "answer": "No accepted answer found."}
{"question": "How can I grep for a string that begins with a dash/hyphen?", "answer": "Use: grep -- -X Documentation Related: What does a bare double dash mean? (thanks to nutty about natty )."}
{"question": "Capturing Groups From a Grep RegEx", "answer": "If you're using Bash, you don't even have to use grep : files=\"*.jpg\" regex=\"[0-9]+_([a-z]+)_[0-9a-z]*\" # put the regex in a variable because some patterns won't work if included literally for f in $files    # unquoted in order to allow the glob to expand do"}
{"question": "How can I make grep print the lines below and above each matching line?", "answer": "grep's -A 1 option will give you one line after; -B 1 will give you one line before; and -C 1 combines both to give you one line both before and after, -1 does the same."}
{"question": "Get line number while using grep", "answer": "grep -n SEARCHTERM file1 file2 ..."}
{"question": "How do I grep for all non-ASCII characters?", "answer": "You can use the command: LC_ALL=C  grep --color='auto' -P -n \"[\\x80-\\xFF]\" file.xml This will give you the line number, and will highlight non-ascii chars in red."}
{"question": "How can I format my grep output to show line numbers at the end of the line, and also the hit count?", "answer": "-n returns line number. -i is for ignore-case. Only to be used if case matching is not necessary $ grep -in null myfile.txt"}
{"question": "How to check if a file contains a specific string using Bash", "answer": "if grep -q SomeString \"$File\"; then   Some Actions # SomeString was found fi"}
{"question": "How to perform grep operation on all files in a directory?", "answer": "No accepted answer found."}
{"question": "Fast way of finding lines in one file that are not in another?", "answer": "You can achieve this by controlling the formatting of the old/new/unchanged lines in GNU diff output: diff --new-line-format=\"\" --unchanged-line-format=\"\"  file1 file2"}
{"question": "How to suppress binary file matching results in grep", "answer": "There are three options, that you can use. -I is to exclude binary files in grep. Other are for line numbers and file names. grep -I -n -H"}
{"question": "How to search and replace using grep", "answer": "No accepted answer found."}
{"question": "Display filename before matching line", "answer": "Try this little trick to coax grep into thinking it is dealing with multiple files, so that it displays the filename: grep 'pattern' file /dev/null"}
{"question": "How can I find all of the distinct file extensions in a folder hierarchy?", "answer": "Try this (not sure if it's the best way, but it works): find . -type f | perl -ne 'print $1 if m/\\.([^.\\/]+)$/' | sort -u It work as following:"}
{"question": "Highlight text similar to grep, but don&#39;t filter out text", "answer": "Use ack. Check out its --passthru option here: ack . It has the added benefit of allowing full Perl regular expressions. $ ack --passthru 'pattern1' file_name      $ command_here | ack --passthru 'pattern1'"}
{"question": "Count all occurrences of a string in lots of files with grep", "answer": "cat * | grep -c string"}
{"question": "How to invert a grep expression", "answer": "Use command-line option -v or --invert-match , ls -R |grep -v -E .*[\\.exe]$\\|.*[\\.html]$"}
{"question": "Grep regex NOT containing a string", "answer": "grep matches, grep -v does the inverse. If you need to \"match A but not B\" you usually use pipes: grep \"${PATT}\" file | grep -v \"${NOTPATT}\""}
{"question": "How to get the process ID to kill a nohup process?", "answer": "When using nohup and you put the task in the background, the background operator ( & ) will give you the PID at the command prompt. If your plan is to manually manage the process, you can save that PID and use it later to kill the process if needed, via kill PID or kill -9 PID (if you need to force kill). Alternatively, you can find the PID later on by ps -ef | grep \"command name\" and locate the PID from there. Note that nohup keyword/command itself does not appear in the ps output for the command in question. If you use a script, you could do something like this in the script: nohup my_command > my.log 2>&1 & echo $! > save_pid.txt"}
{"question": "What is makeinfo, and how do I get it?", "answer": "In (at least) Ubuntu when using bash , it tells you what package you need to install if you type in a command and its not found in your path. My terminal says you need to install 'texinfo' package. sudo apt-get install texinfo"}
{"question": "How to search contents of multiple pdf files?", "answer": "Your distribution should provide a utility called pdftotext : find /path -name '*.pdf' -exec sh -c 'pdftotext \"{}\" - | grep --with-filename --label=\"{}\" --color \"your pattern\"' \\;"}
{"question": "How can I have grep not print out &#39;No such file or directory&#39; errors?", "answer": "You can use the -s or --no-messages flag to suppress errors. -s, --no-messages         suppress error messages"}
{"question": "Match two strings in one line with grep", "answer": "You can use grep 'string1' filename | grep 'string2' This searches for string1 followed by string 2 on the same line, or string2 followed by string1 on the same line; it does not answer the question: grep 'string1.*string2\\|string2.*string1' filename"}
{"question": "grep without showing path/file:line", "answer": "No need to find . If you are just looking for a pattern within a specific directory, this should suffice: grep -h FOO /your/path/*.bar Where -h is the parameter to hide the filename, as from man grep :"}
{"question": "Regex (grep) for multi-line search needed", "answer": "Without the need to install the grep variant pcregrep , you can do a multiline search with grep. $ grep -Pzo \"(?s)^(\\s*)\\N*main.*?{.*?^\\1}\" *.c Explanation: -P activate perl-regexp for grep (a powerful extension of regular expressions)"}
{"question": "How to find patterns across multiple lines using grep?", "answer": "Grep is an awkward tool for this operation. pcregrep which is found in most of the modern Linux systems can be used as pcregrep -M 'abc.*(\\n|.)*efg' test.txt where -M , --multiline allow patterns to match more than one line"}
{"question": "How to concatenate multiple lines of output to one line?", "answer": "Use tr '\\n' ' ' to translate all newline characters to spaces: $ grep pattern file | tr '\\n' ' '"}
{"question": "What are good grep tools for Windows?", "answer": "Based on recommendations in the comments, I've started using grepWin and it's fantastic and free . (I'm still a fan of PowerGREP , but I don't use it anymore.) I know you already mentioned it, but PowerGREP is awesome . Some of my favorite features are:"}
{"question": "Using grep to search for a string that has a dot in it", "answer": "grep uses regexes; . means \"any character\" in a regex.  If you want a literal string, use grep -F , fgrep , or escape the . to \\. . Don't forget to wrap your string in double quotes. Or else you should use \\\\. So, your command would need to be:"}
{"question": "How to show only next line after the matched one?", "answer": "you can try with awk: awk '/blah/{getline; print}' logfile"}
{"question": "Exploitable PHP functions", "answer": "To build this list I used 2 sources. A Study In Scarlet and RATS .   I have also added some of my own to the mix and people on this thread have helped out. Edit: After posting this list I contacted the founder of RIPS and as of now this tools searches PHP code for the use of every function in this list. Most of these function calls are classified as Sinks. When a tainted variable (like $_REQUEST) is passed to a sink function, then you have a vulnerability.  Programs like RATS and RIPS use grep like functionality to identify all sinks in an application.  This means that programmers should take extra care when using these functions,  but if they where all banned then you wouldn't be able to get much done."}
{"question": "How to grep a string in a directory and all its subdirectories?", "answer": "If your grep supports -R , do: grep -R 'string' dir/"}
{"question": "PowerShell equivalent to grep -f", "answer": "The -Pattern parameter in Select-String supports an array of patterns. So the one you're looking for is: Get-Content .\\doc.txt | Select-String -Pattern (Get-Content .\\regex.txt)"}
{"question": "Is there a Pattern Matching Utility like GREP in Windows?", "answer": "I also found one more way of utilizing GREP like functionality in Windows 7 and above without any extra application to install and on older systems you can use install Powershell. In Powershell , User can use Where-Object it has quite comprehensive set of feature that provides all the functionality of GREP plus more. Hope It helps."}
{"question": "grep output to show only matching file", "answer": "grep -l (That's a lowercase L)"}
{"question": "How to grep for case insensitive string in a file?", "answer": "You can use the -i flag which makes your pattern case insensitive: grep -iF \"success...\" file1"}
{"question": "Remove blank lines with grep", "answer": "Try the following: grep -v -e '^$' foo.txt The -e option allows regex patterns for matching. The single quotes around ^$ makes it work for Cshell. Other shells will be happy with either single or double quotes."}
{"question": "Windows recursive grep command-line", "answer": "findstr can do recursive searches (/S) and supports some variant of regex syntax (/R). C:\\>findstr /? Searches for strings in files."}
{"question": "How to do a non-greedy match in grep?", "answer": "You're looking for a non-greedy (or lazy) match. To get a non-greedy match in regular expressions you need to use the modifier ? after the quantifier. For example you can change .* to .*? . By default grep doesn't support non-greedy modifiers, but you can use grep -P to use the Perl syntax."}
{"question": "Validating IPv4 addresses with regexp", "answer": "You've already got a working answer but just in case you are curious what was wrong with your original approach, the answer is that you need parentheses around your alternation otherwise the (\\.|$) is only required if the number is less than 200. '\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b'     ^                                    ^"}
{"question": "Grep &#39;binary file matches&#39;. How to get normal grep output?", "answer": "Try: grep --text"}
{"question": "How can I get `find` to ignore .svn directories?", "answer": "For searching, can I suggest you look at ack ? It's a source-code aware find , and as such will automatically ignore many file types, including source code repository info such as the above."}
{"question": "How do I fetch lines before/after the grep result in bash?", "answer": "You can use the -B and -A to print lines before and after the match. grep -i -B 10 'error' data"}
{"question": "Grep characters before and after match?", "answer": "3 characters before and 4 characters after $> echo \"some123_string_and_another\" | grep -o -P '.{0,3}string.{0,4}' 23_string_and"}
{"question": "Checking if output of a command contains a certain string in a shell script", "answer": "Test the return value of grep: ./somecommand | grep 'string' &> /dev/null if [ $? == 0 ]; then    echo \"matched\""}
{"question": "Finding a string in docker logs of container", "answer": "this can happen if the container is logging to stderr, piping works only for stdout, so try: docker logs nginx 2>&1 | grep \"127.\" \" 2>&1 \" will tell the shell to redirect stderr to stdout"}
{"question": "How to use sed/grep to extract text between two words?", "answer": "sed -e 's/Here\\(.*\\)String/\\1/'"}
{"question": "How to merge every two lines into one from the command line?", "answer": "awk: awk 'NR%2{printf \"%s \",$0;next;}1' yourFile"}
{"question": "(grep) Regex to match non-ASCII characters?", "answer": "This will match a single non-ASCII character: [^\\x00-\\x7F]"}
{"question": "How can I &quot;grep&quot; for a filename instead of the contents of a file?", "answer": "You need to use find instead of grep in this case. You can also use find in combination with grep or egrep : $ find | grep \"f[[:alnum:]]\\.frm\""}
{"question": "List files with certain extensions with ls and grep", "answer": "Why not: ls *.{mp3,exe,mp4}"}
{"question": "How to remove the lines which appear on file B from another file A?", "answer": "If the files are sorted (they are in your example): comm -23 file1 file2"}
{"question": "How to get the part of a file after the first line that matches a regular expression", "answer": "The following will print the line matching TERMINATE till the end of the file: sed -n -e '/TERMINATE/,$p' Explained: -n disables default behavior of sed of printing each line after executing its script on it, -e indicated a script to sed , /TERMINATE/,$ is an address (line) range selection meaning the first line matching the TERMINATE regular expression (like grep) to the end of the file ( $ ), and p is the print command which prints the current line. This will print from the line that follows the line matching TERMINATE till the end of the file:"}
{"question": "How to exclude certain directories/files from a Git grep search", "answer": "It is not possible in older versions of Git, but it was discussed . A proposed workaround is in the link: You can put *.dll to .gitignore file then git grep --exclude-standard . See also onlynone's answer , since Git 1.9.0 it's possible."}
{"question": "How to process each output line in a loop?", "answer": "One of the easy ways is not to store the output in a variable, but directly iterate over it with a while/read loop. Something like: grep xyz abc.txt | while read -r line ; do"}
{"question": "Preserve colouring after piping grep to grep", "answer": "grep sometimes disables the color output, for example when writing to a pipe. You can override this behavior with grep --color=always The correct command line would be grep --color=always WORD * | grep -v AVOID"}
{"question": "How do I use grep to search the current directory for all files having the a string &quot;hello&quot; yet display only .h and .cc files?", "answer": "grep -r --include=*.{cc,h} \"hello\" . This reads: search recursively (in all sub directories also) for all .cc OR .h files that contain \"hello\" at this . (current) directory"}
{"question": "Is it possible to perform a &#39;grep search&#39; in all the branches of a Git project?", "answer": "The question \" How to grep (search) committed code in the Git history? \" recommends: git grep <regexp> $(git rev-list --all) That searches through all the commits, which should include all the branches. Another form would be:"}
{"question": "Exclude .svn directories from grep", "answer": "If you have GNU Grep, it should work like this: grep --exclude-dir=\".svn\""}
{"question": "More elegant &quot;ps aux | grep -v grep&quot;", "answer": "The usual technique is this: ps aux | egrep '[t]erminal'"}
{"question": "How to search a specific value in all tables (PostgreSQL)?", "answer": "How about dumping the contents of the database, then using grep ? $ pg_dump --data-only --inserts -U postgres your-db-name > a.tmp $ grep United a.tmp INSERT INTO countries VALUES ('US', 'United States');"}
{"question": "How to grep for two words existing on the same line?", "answer": "Why do you pass -c ? That will just show the number of matches. Similarly, there is no reason to use -r . I suggest you read man grep . To grep for 2 words existing on the same line, simply do: grep \"word1\" FILE | grep \"word2\""}
{"question": "How do you search for files containing DOS line endings (CRLF) with grep on Linux?", "answer": "grep probably isn't the tool you want for this.  It will print a line for every matching line in every file.  Unless you want to, say, run todos 10 times on a 10 line file, grep isn't the best way to go about it.  Using find to run file on every file in the tree then grepping through that for \"CRLF\" will get you one line of output for each file which has dos style line endings: find . -not -type d -exec file \"{}\" \";\" | grep CRLF will get you something like:"}
{"question": "How can I search for a multiline pattern in a file?", "answer": "So I discovered pcregrep which stands for Perl Compatible Regular Expressions GREP . the -M option makes it possible to search for patterns that span line boundaries. For example, you need to find files where the ' _name ' variable is followed on the next line by the ' _description ' variable:"}
{"question": "grep exclude multiple strings", "answer": "No accepted answer found."}
{"question": "Can I grep only the first n lines of a file?", "answer": "The magic of pipes; head -10 log.txt | grep <whatever>"}
{"question": "Is \\d not supported by grep&#39;s basic expressions?", "answer": "As specified in POSIX, grep uses basic regular expressions , but \\d is part of a Perl-compatible regular expression ( PCRE ). If you are using GNU grep, you can use the -P option, to allow use of PCRE regular expressions. Otherwise you can use the POSIX-specified [[:digit:]] character class in place of \\d . echo 1 | grep -P '\\d' # output: 1 echo 1 | grep '[[:digit:]]'"}
{"question": "Grepping a huge file (80GB) any way to speed it up?", "answer": "Here are a few options: 1) Prefix your grep command with LC_ALL=C to use the C locale instead of UTF-8. 2) Use fgrep because you're searching for a fixed string, not a regular expression."}
{"question": "How can I extract the first two characters of a string in shell scripting?", "answer": "No accepted answer found."}
{"question": "How to grep for the whole word", "answer": "You want the -w option to specify that it's the end of a word. find . | xargs grep -sw 's:text'"}
{"question": "What are the differences among grep, awk &amp; sed?", "answer": "Short definition: grep : search for specific terms in a file #usage"}
{"question": "Using the star sign in grep", "answer": "For such two-part matches, use .* between the two parts. For instance: grep 'abc.*def' myFile will match a string that contains abc followed by def with something optionally in between."}
{"question": "How to give a pattern for new line in grep?", "answer": "grep patterns are matched against individual lines so there is no way for a pattern to match a newline found in the input. However you can find empty lines like this: grep '^$' file"}
{"question": "Using sed, how do you print the first &#39;N&#39; characters of a line?", "answer": "Don't use sed , use cut : grep .... | cut -c 1-N"}
{"question": "grep for special characters in Unix", "answer": "Tell grep to treat your input as fixed string using -F option. grep -F '*^%Q&$*&^@$&*!^@$*&^&^*&^&' application.log"}
{"question": "How do you grep a file and get the next 5 lines", "answer": "You want: grep -A 5 '19:55' file"}
{"question": "Use grep to report back only line numbers", "answer": "try: grep -n \"text to find\" file.ext | cut -f1 -d:"}
{"question": "How to grep for contents after pattern?", "answer": "grep 'potato:' file.txt | sed 's/^.*: //' grep looks for any line that contains the string potato: , then, for each of these lines, sed replaces ( s/// - substitute) any character ( .* ) from the beginning of the line ( ^ ) until the last occurrence of the sequence : (colon followed by space) with the empty string ( s/...// - substitute the first part with the second part, which is empty)."}
{"question": "Grep for literal strings", "answer": "You can use grep for that, with the -F option. -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings"}
{"question": "How does grep run so fast?", "answer": "Assuming your question regards GNU grep specifically. Here's a note from the author, Mike Haertel: GNU grep is fast because it AVOIDS LOOKING AT EVERY INPUT BYTE."}
{"question": "Redirect stderr to /dev/null for two piped commands: find | grep", "answer": "In order to redirect stderr to /dev/null use: some_cmd 2>/dev/null"}
{"question": "Regex lookahead for &#39;not followed by&#39; in grep", "answer": "Negative lookahead, which is what you're after, requires a more powerful tool than the standard grep .  You need a PCRE-enabled grep. If you have GNU grep , the current version supports options -P or --perl-regexp and you can then use the regex you wanted. If you don't have (a sufficiently recent version of) GNU grep , then consider getting ack ."}
{"question": "How to truncate long matching lines returned by grep or ack", "answer": "You could use the grep options -oE , possibly in combination with changing your pattern to \".{0,10}<original pattern>.{0,10}\" in order to see some context around it: -o, --only-matching               Show only the part of a matching line that matches PATTERN."}
{"question": "git grep by file extensions", "answer": "Yes, for example: git grep res -- '*.js'"}
{"question": "How can I grep hidden files?", "answer": "Please refer to the solution at the end of this post as a better alternative to what you're doing. You can explicitly include hidden files (a directory is also a file). grep -r search * .[^.]* The * will match all files except hidden ones and .[^.]* will match only hidden files without .. . However this will fail if there are either no non-hidden files or no hidden files in a given directory. You could of course explicitly add .git instead of .* ."}
{"question": "how do I use the grep --include option for multiple file types?", "answer": "You can use multiple --include flags. This works for me: grep -r --include=*.html --include=*.php --include=*.htm \"pattern\" /some/path/ However, you can do as Deruijter suggested . This works for me: grep -r --include=*.{html,php,htm} \"pattern\" /some/path/"}
{"question": "Grep not as a regular expression", "answer": "Escape the $ by putting a \\ in front of it."}
{"question": "How to display modified date time with &#39;find&#39; command?", "answer": "You could use the -exec switch for find and define the output format of stat using the -c switch as follows: find /var -maxdepth 2 -type d -exec stat  -c \"%n %y\" {} \\; This should give the filename followed by its modification time on the same line of the output."}
{"question": "How to make grep only match if the entire line matches?", "answer": "Simply specify the regexp anchors. grep '^ABB\\.log$' a.tmp"}
{"question": "Show filename and line number in grep output", "answer": "I think -l is too restrictive as it suppresses the output of -n . I would suggest -H ( --with-filename ): Print the filename for each match. grep -Hn \"search\" *"}
{"question": "Output grep results to text file, need cleaner output", "answer": "No accepted answer found."}
{"question": "Prevent grep returning an error when input doesn&#39;t match", "answer": "Sure: ps -ef | grep bar | { grep -v grep || true; }"}
{"question": "grep regex whitespace behavior", "answer": "This looks like a behavior difference in the handling of \\s between grep 2.5 and newer versions (a bug in old grep?).  I confirm your result with grep 2.5.4, but all four of your greps do work when using grep 2.6.3 (Ubuntu 10.10). Note: GNU grep 2.5.4"}
{"question": "How to grep the git diff?", "answer": "Not sure but isn't git diff -G <regex> flag OK? -G < regex>"}
{"question": "Linux find and grep command together", "answer": "You are looking for -H option in gnu grep. find . -name '*bills*' -exec grep -H \"put\" {} \\;"}
{"question": "How to grep, excluding some patterns?", "answer": "No accepted answer found."}
{"question": "How to grep with a list of words", "answer": "You need to use the option -f : $ grep -f A B"}
{"question": "How to find all file extensions recursively from a directory?", "answer": "How about this: find . -type f -name '*.*' | sed 's|.*\\.||' | sort -u"}
{"question": "grepping using the &quot;|&quot; alternative operator", "answer": "You need to escape the | .  The following should do the job. grep \"gene\\|exon\" AT5G60410.gff"}
{"question": "Remove empty lines in a text file via grep", "answer": "grep . FILE (And if you really want to do it in sed, then: sed -e /^$/d FILE )"}
{"question": "Using sed and grep/egrep to search and replace", "answer": "Use this command: egrep -lRZ \"\\.jpg|\\.png|\\.gif\" . \\     | xargs -0 -l sed -i -e 's/\\.jpg\\|\\.gif\\|\\.png/.bmp/g'"}
{"question": "grep for multiple strings in file on different lines (ie. whole file, not line based search)?", "answer": "No accepted answer found."}
{"question": "Count number of occurrences of a pattern in a file (even on same line)", "answer": "To count all occurrences, use -o . Try this: echo afoobarfoobar | grep -o foo | wc -l"}
{"question": "How to use grep to get anything just after `name=`?", "answer": "As detailed here , you want a positive lookbehind clause, such as: grep -P '(?<=name=)[ A-Za-z0-9]*' filename"}
{"question": "How to &quot;grep&quot; out specific line ranges of a file", "answer": "Try using sed as mentioned on http://linuxcommando.blogspot.com/2008/03/using-sed-to-extract-lines-in-text-file.html . For example use sed '2,4!d' somefile.txt to print from the second line to the fourth line of somefile.txt . (And don't forget to check http://www.grymoire.com/Unix/Sed.html , sed is a wonderful tool.)"}
{"question": "Difference between egrep and grep", "answer": "No accepted answer found."}
{"question": "Grep and Python", "answer": "No accepted answer found."}
{"question": "Grep for beginning and end of line?", "answer": "No accepted answer found."}
{"question": "How to escape parenthesis in grep", "answer": "It depends.  If you use regular grep, you don't escape: echo '(foo)' | grep '(fo*)' You actually have to escape if you want to use the parentheses as grouping. If you use extended regular expressions , you do escape:"}
{"question": "Grep - how to output only the content of a capturing group", "answer": "If you have either pcregrep or pcre2grep you can use the -o1 command-line flag to request that only capture group 1 is output. (Or change 1 to some other number if there are more captures in the regex.) You can use the -o N command more than once if you want to output more than one capture group. As far as I know, grep -P does not implement this extension. You'll find pcre2grep in Debian/Ubuntu package pcre2-utils . pcregrep is in package pcregrep ."}
{"question": "grep --ignore-case --only", "answer": "This is a known bug on the initial 2.5.1, and has been fixed in early 2007 (Redhat 2.5.1-5) according to the bug reports. Unfortunately Apple is still using 2.5.1 even on Mac OS X 10.7.2 . You could get a newer version via Homebrew (3.0) or MacPorts (2.26) or fink (3.0-1) . Edit: Apparently it has been fixed on OS X 10.11 (or maybe earlier), even though the grep version reported is still 2.5.1."}
{"question": "How to find and replace all occurrences of a string recursively in a directory tree?", "answer": "No accepted answer found."}
{"question": "Delete a list of files with find and grep", "answer": "find . -name '*car*' -exec rm -f {} \\; or pass the output of your pipeline to xargs :"}
{"question": "changing chmod for files but not directories", "answer": "A find -exec answer is a good one but it suffers from the usually irrelevant shortcoming that it creates a separate sub-process for every single file. However it's perfectly functional and will only perform badly when the number of files gets really large. Using xargs will batch up the file names into large groups before running a sub-process for that group of files. You just have to be careful that, in using xargs , you properly handle filenames with embedded spaces, newlines or other special characters in them. A solution that solves both these problems is (assuming you have a decent enough find and xargs implementation):"}
{"question": "How do I get rid of &quot;--&quot; line separator when using grep with context lines?", "answer": "No accepted answer found."}
{"question": "Always include first line in grep", "answer": "You could include an alternate pattern match for the one of the column names. If a column was called COL then this would work: $ grep -E 'COL|pattern' file.csv"}
{"question": "How to remove leading whitespace from each line in a file", "answer": "sed \"s/^[ \\t]*//\" -i youfile Warning: this will overwrite the original file."}
{"question": "grep only text files", "answer": "You can use the -r (recursive) and -I (ignore binary) options in grep : $ grep -rI \"TEXTSEARCH\" ."}
{"question": "How can I check if &#39;grep&#39; doesn&#39;t have any output?", "answer": "Just do a simple if like this: if grep -q $address  /etc/passwd then     echo \"OK\";"}
{"question": "Command line: search and replace in all filenames matched by grep", "answer": "Do you mean search and replace a string in all files matched by grep? perl -p -i -e 's/oldstring/newstring/g' `grep -ril searchpattern *`"}
{"question": "Fastest possible grep", "answer": "Try with GNU parallel , which includes an example of how to use it with grep : grep -r greps recursively through directories. On multicore CPUs GNU parallel can often speed this up."}
{"question": "Using grep and sed to find and replace a string", "answer": "You can use find and -exec directly into sed rather than first locating oldstr with grep .  It's maybe a bit less efficient, but that might not be important.  This way, the sed replacement is executed over all files listed by find , but if oldstr isn't there it obviously won't operate on it. find /path -type f -exec sed -i 's/oldstr/newstr/g' {} \\;"}
{"question": "Recursively cat all the files into single file", "answer": "find data/ -name '*.json' -exec cat {} \\; > uber.json a short explanation:"}
{"question": "Bash, grep between two lines with specified string", "answer": "Print from test1 to test2 (Trigger lines included) awk '/test1/{f=1} /test2/{f=0;print} f'"}
{"question": "Store grep output in an array", "answer": "Old answer (written in the year 2014) made an assumption that output filenames won't contain special characters like whitespaces or globs. Here is a safe way to read those special filenames into an array: (will work with older bash versions) while IFS= read -rd ''; do    targets+=(\"$REPLY\") done < <(grep --null -HRl \"pattern\" .)"}
{"question": "grepping binary files and UTF16", "answer": "The easiest way is to just convert the text file to utf-8 and pipe that to grep: iconv -f utf-16 -t utf-8 file.txt | grep query"}
{"question": "Pattern matching digits does not work in egrep?", "answer": "egrep doesn't recognize \\d shorthand for digit character class, so you need to use e.g. [0-9] . Moreover, while it's not absolutely necessary in this case, it's good habit to quote the regex to prevent misinterpretation by the shell. Thus, something like this should work: egrep '[0-9]{7}-[0-9]{10}' file"}
{"question": "How to match once per file in grep?", "answer": "I think you can just do something like grep -ri -m1 --include '*.coffee' 're' . | head -n 2"}
{"question": "How to grep for the dollar symbol ($)?", "answer": "The problem is that the shell expands variable names inside double-quoted strings. So for \"$$$\" it tries to read a variable name starting with the first $ . In single quotes, on the other hand, variables are not expanded. Therefore, '$$$' would work – if it were not for the fact that $ is a special character in regular expressions denoting the line ending. So it needs to be escaped: '\\$\\$\\$' ."}
{"question": "Spider a Website and Return URLs Only", "answer": "The absolute last thing I want to do is download and parse all of the content myself (i.e. create my own spider). Once I learned that Wget writes to stderr by default, I was able to redirect it to stdout and filter the output appropriately. wget --spider --force-html -r -l2 $url 2>&1 \\   | grep '^--' | awk '{ print $3 }' \\   | grep -v '\\.\\(css\\|js\\|png\\|gif\\|jpg\\)$' \\   > urls.m3u"}
{"question": "shell variable in a grep regex", "answer": "You need to use double quotes. Single quotes prevent the shell variable from being interpolated by the shell. You use single quotes to prevent the shell from doing interpolation which you may have to do if your regular expression used $ as part of the pattern. You can also use a backslash to quote a $ if you're using double quotes. Also, you may need to put your variable in curly braces ${var} in order to help separate it from the rest of the pattern. Example: $ string=\"test this\" $ var=\"test\""}
